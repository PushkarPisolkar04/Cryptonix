"""
Stage 3: Vulnerability Assessment
Comprehensive vulnerability scanning using multiple tools
"""

import asyncio
from typing import Dict, Any

from loguru import logger

from stages.base import BaseStage
from modules.vuln_scan.nessus_scanner import NessusScanner
from modules.vuln_scan.openvas_scanner import OpenVASScanner
from modules.vuln_scan.zap_scanner import ZAPScanner
from modules.vuln_scan.sqlmap_runner import SQLMapRunner
from modules.vuln_scan.nikto_scanner import NiktoScanner
from modules.vuln_scan.builtin_scanner import BuiltinScanner
from core.models import Vulnerability, Severity


class VulnerabilityStage(BaseStage):
    """Comprehensive vulnerability assessment"""
    
    @property
    def name(self) -> str:
        return "Vulnerability Assessment"
    
    @property
    def description(self) -> str:
        return "Deep vulnerability scanning: Nessus, OpenVAS, ZAP, SQLMap, Nikto"
    
    async def run(self) -> Dict[str, Any]:
        """Execute vulnerability scanning"""
        
        discovery_data = self.get_previous_stage_data('discovery')
        hosts = discovery_data.get('hosts', [])
        
        if not hosts:
            logger.warning("No hosts from discovery stage, skipping vulnerability scan")
            return {'vulnerabilities': []}
        
        results = {
            'vulnerabilities': [],
            'scan_results': {}
        }
        
        tasks = []
        
        # Web application scanning
        web_hosts = [h for h in hosts if any(p.get('service') in ['http', 'https'] for p in h.open_ports)]
        
        if web_hosts:
            # Always run built-in scanner (no external dependencies)
            logger.info("üîç Running built-in vulnerability scanner...")
            builtin = BuiltinScanner(self.config)
            tasks.append(self._run_builtin(builtin, web_hosts, results))
            
            # Optional: Run external tools if available
            logger.info("üåê Running OWASP ZAP scan...")
            zap = ZAPScanner(self.config)
            tasks.append(self._run_zap(zap, web_hosts, results))
            
            logger.info("üíâ Running SQLMap...")
            sqlmap = SQLMapRunner(self.config)
            tasks.append(self._run_sqlmap(sqlmap, web_hosts, results))
            
            logger.info("üîç Running Nikto...")
            nikto = NiktoScanner(self.config)
            tasks.append(self._run_nikto(nikto, web_hosts, results))
        
        # Nessus/OpenVAS for comprehensive scanning (optional)
        if self.config.tools.nessus_url:
            logger.info("üîç Running Nessus scan...")
            nessus = NessusScanner(self.config)
            tasks.append(self._run_nessus(nessus, hosts, results))
        
        # Wait for all scans
        await asyncio.gather(*tasks, return_exceptions=True)
        
        # Deduplicate and prioritize vulnerabilities
        results['vulnerabilities'] = self._deduplicate_vulns(results['vulnerabilities'])
        
        logger.success(f"‚úÖ Found {len(results['vulnerabilities'])} vulnerabilities")
        
        return results
    
    async def _run_builtin(self, scanner, hosts, results):
        try:
            vulns = await scanner.scan(hosts)
            results['vulnerabilities'].extend(vulns)
            results['scan_results']['builtin'] = {'count': len(vulns)}
        except Exception as e:
            logger.error(f"Built-in scan failed: {e}")
    
    async def _run_nessus(self, scanner, hosts, results):
        try:
            vulns = await scanner.scan(hosts)
            results['vulnerabilities'].extend(vulns)
            results['scan_results']['nessus'] = {'count': len(vulns)}
        except Exception as e:
            logger.error(f"Nessus scan failed: {e}")
    
    async def _run_openvas(self, scanner, hosts, results):
        try:
            vulns = await scanner.scan(hosts)
            results['vulnerabilities'].extend(vulns)
            results['scan_results']['openvas'] = {'count': len(vulns)}
        except Exception as e:
            logger.error(f"OpenVAS scan failed: {e}")
    
    async def _run_zap(self, scanner, hosts, results):
        try:
            vulns = await scanner.scan(hosts)
            results['vulnerabilities'].extend(vulns)
            results['scan_results']['zap'] = {'count': len(vulns)}
        except Exception as e:
            logger.error(f"ZAP scan failed: {e}")
    
    async def _run_sqlmap(self, runner, hosts, results):
        try:
            vulns = await runner.scan(hosts)
            results['vulnerabilities'].extend(vulns)
            results['scan_results']['sqlmap'] = {'count': len(vulns)}
        except Exception as e:
            logger.error(f"SQLMap failed: {e}")
    
    async def _run_nikto(self, scanner, hosts, results):
        try:
            vulns = await scanner.scan(hosts)
            results['vulnerabilities'].extend(vulns)
            results['scan_results']['nikto'] = {'count': len(vulns)}
        except Exception as e:
            logger.error(f"Nikto scan failed: {e}")
    
    def _deduplicate_vulns(self, vulns):
        """Remove duplicate vulnerabilities"""
        seen = set()
        unique = []
        
        for vuln in vulns:
            # Handle both dict and object formats
            if isinstance(vuln, dict):
                key = (vuln.get('name'), vuln.get('url'), vuln.get('id'))
            else:
                key = (vuln.name, vuln.affected_service, vuln.affected_port)
            
            if key not in seen:
                seen.add(key)
                unique.append(vuln)
        
        # Sort by severity
        severity_order = {
            'critical': 0,
            'high': 1,
            'medium': 2,
            'low': 3,
            'info': 4,
            Severity.CRITICAL: 0,
            Severity.HIGH: 1,
            Severity.MEDIUM: 2,
            Severity.LOW: 3,
            Severity.INFO: 4
        }
        
        def get_severity(v):
            if isinstance(v, dict):
                return severity_order.get(v.get('severity', 'info'), 5)
            return severity_order.get(v.severity, 5)
        
        return sorted(unique, key=get_severity)
