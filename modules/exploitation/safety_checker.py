"""Pre-exploitation safety checks"""
import asyncio
from pathlib import Path
from typing import Dict, Any
from loguru import logger

class SafetyChecker:
    def __init__(self, config, scope):
        self.config = config
        self.scope = scope
    
    async def verify_authorization(self) -> bool:
        logger.info("Verifying authorization...")
        
        # Check for scope document
        if self.scope.scope_file:
            scope_path = Path(self.scope.scope_file)
            if not scope_path.exists():
                logger.error("Scope file not found")
                return False
        
        # Check for authorization fields
        if hasattr(self.scope, 'authorized_by') and self.scope.authorized_by:
            logger.success(f"Authorized by: {self.scope.authorized_by}")
            return True
        
        # In dry-run mode, always allow
        if self.scope.dry_run:
            logger.info("Dry-run mode: Authorization check bypassed")
            return True
        
        logger.warning("No authorization found - proceeding with caution")
        return True
    
    async def check_target_safety(self, target: str) -> Dict[str, Any]:
        checks = {
            'is_private_ip': self._is_private_ip(target),
            'is_localhost': target in ['localhost', '127.0.0.1', '::1'],
            'is_excluded': target in getattr(self.scope, 'excluded_hosts', []),
            'safe_to_scan': True
        }
        
        if checks['is_excluded']:
            checks['safe_to_scan'] = False
            logger.warning(f"Target {target} is in exclusion list")
        
        return checks
    
    def _is_private_ip(self, ip: str) -> bool:
        try:
            import ipaddress
            return ipaddress.ip_address(ip).is_private
        except:
            return False
    
    async def pre_exploit_check(self, exploit_info: Dict) -> bool:
        logger.info(f"Safety check for exploit: {exploit_info.get('name', 'unknown')}")
        
        # Check if dry-run
        if self.scope.dry_run:
            logger.info("Dry-run mode: Exploit will be simulated")
            return True
        
        # Check exploit risk level
        risk = exploit_info.get('risk', 'medium').lower()
        if risk in ['critical', 'high']:
            logger.warning(f"High-risk exploit: {risk}")
        
        return True
