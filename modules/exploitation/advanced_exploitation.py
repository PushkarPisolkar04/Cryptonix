"""
Advanced Exploitation Module with Safety Controls
Stage 6: Controlled exploitation with dry-run, rollback, rate limiting, and stealth
"""

import asyncio
import json
import time
from datetime import datetime
from typing import Dict, List, Optional, Callable
from dataclasses import dataclass, asdict
from pathlib import Path
from enum import Enum

from loguru import logger


class ExploitationMode(Enum):
    """Exploitation execution modes"""
    DRY_RUN = 1  # Simulate without execution
    PRODUCTION = 2  # Actual exploitation
    STEALTH = 3  # Slow, anti-forensics


@dataclass
class ExploitAction:
    """Individual exploit action"""
    id: str
    name: str
    description: str
    command: str
    severity: str
    reversible: bool
    rollback_command: Optional[str] = None
    estimated_duration: float = 5.0  # seconds
    detection_risk: str = 'medium'  # low, medium, high


@dataclass
class ExploitationResult:
    """Result of exploitation attempt"""
    timestamp: str
    exploit_id: str
    exploit_name: str
    target: str
    success: bool
    output: str
    error: Optional[str]
    duration: float
    actions_taken: List[ExploitAction]
    rolled_back: bool = False


class RateLimiter:
    """Rate limiting for stealth execution"""

    def __init__(self, requests_per_second: float = 1.0):
        self.requests_per_second = requests_per_second
        self.min_interval = 1.0 / requests_per_second
        self.last_request_time = 0.0

    async def wait(self):
        """Wait if needed to respect rate limit"""
        elapsed = time.time() - self.last_request_time
        if elapsed < self.min_interval:
            await asyncio.sleep(self.min_interval - elapsed)
        self.last_request_time = time.time()


class RollbackManager:
    """Manages rollback of exploitation actions"""

    def __init__(self):
        self.executed_actions: List[ExploitAction] = []
        self.rollback_log: List[Dict] = []

    def record_action(self, action: ExploitAction):
        """Record an executed action"""
        self.executed_actions.append(action)
        logger.debug(f"Recorded action for potential rollback: {action.name}")

    async def rollback_all(self):
        """Rollback all executed actions in reverse order"""
        logger.warning("Initiating rollback of all exploitation actions")
        
        for action in reversed(self.executed_actions):
            if action.reversible and action.rollback_command:
                try:
                    logger.info(f"Rolling back: {action.name}")
                    # Execute rollback
                    await self._execute_rollback(action)
                    self.rollback_log.append({
                        'action': action.name,
                        'status': 'success',
                        'timestamp': datetime.now().isoformat()
                    })
                except Exception as e:
                    logger.error(f"Rollback failed for {action.name}: {e}")
                    self.rollback_log.append({
                        'action': action.name,
                        'status': 'failed',
                        'error': str(e),
                        'timestamp': datetime.now().isoformat()
                    })

    async def _execute_rollback(self, action: ExploitAction):
        """Execute rollback command"""
        # This would execute the actual rollback command
        # In real scenario: run the rollback_command
        pass


class SafetyChecker:
    """Safety controls for exploitation"""

    def __init__(self):
        self.emergency_stop_triggered = False
        self.protected_assets = []

    async def check_safety(self, action: ExploitAction, target: str) -> bool:
        """Check if action is safe to execute"""
        if self.emergency_stop_triggered:
            logger.error("EMERGENCY STOP triggered, aborting execution")
            return False

        if target in self.protected_assets:
            logger.error(f"Target {target} is protected, cannot execute")
            return False

        # Additional safety checks
        if action.detection_risk == 'high':
            logger.warning(f"High detection risk for {action.name}")

        return True

    async def trigger_emergency_stop(self):
        """Trigger emergency stop"""
        logger.critical("EMERGENCY STOP triggered!")
        self.emergency_stop_triggered = True

    def add_protected_asset(self, asset: str):
        """Mark asset as protected (won't be exploited)"""
        self.protected_assets.append(asset)
        logger.info(f"Asset protected: {asset}")


class SessionManager:
    """Manages multiple simultaneous compromise sessions"""

    def __init__(self):
        self.sessions: Dict[str, Dict] = {}

    def create_session(self, target: str, session_type: str) -> str:
        """Create new session"""
        session_id = f"session_{len(self.sessions)}_{int(time.time())}"
        self.sessions[session_id] = {
            'target': target,
            'type': session_type,
            'created_at': datetime.now(),
            'commands_executed': [],
            'privileges': 'user',
            'active': True
        }
        logger.info(f"Session created: {session_id} for {target}")
        return session_id

    def get_session(self, session_id: str) -> Optional[Dict]:
        """Get session details"""
        return self.sessions.get(session_id)

    def update_privileges(self, session_id: str, new_privilege: str):
        """Update session privilege level"""
        if session_id in self.sessions:
            self.sessions[session_id]['privileges'] = new_privilege
            logger.info(f"Session {session_id} privilege escalated to {new_privilege}")

    def execute_command(self, session_id: str, command: str) -> bool:
        """Record command execution in session"""
        if session_id in self.sessions and self.sessions[session_id]['active']:
            self.sessions[session_id]['commands_executed'].append({
                'command': command,
                'timestamp': datetime.now()
            })
            return True
        return False

    def close_session(self, session_id: str):
        """Close session"""
        if session_id in self.sessions:
            self.sessions[session_id]['active'] = False
            logger.info(f"Session {session_id} closed")

    def list_active_sessions(self) -> List[Dict]:
        """List all active sessions"""
        return [
            {'id': sid, **s} for sid, s in self.sessions.items()
            if s['active']
        ]


class AdvancedExploitationRunner:
    """Main exploitation runner with safety controls"""

    def __init__(self, config: Dict):
        self.config = config
        self.mode = ExploitationMode.DRY_RUN  # Default to dry-run
        self.rate_limiter = RateLimiter(config.get('requests_per_second', 1.0))
        self.rollback_manager = RollbackManager()
        self.safety_checker = SafetyChecker()
        self.session_manager = SessionManager()

    async def execute_exploit(
        self,
        exploit_id: str,
        exploit_name: str,
        target: str,
        actions: List[ExploitAction],
        mode: Optional[ExploitationMode] = None
    ) -> ExploitationResult:
        """Execute exploit with safety controls"""
        logger.info(f"Executing exploit: {exploit_name} against {target}")

        mode = mode or self.mode
        start_time = time.time()
        result = ExploitationResult(
            timestamp=datetime.now().isoformat(),
            exploit_id=exploit_id,
            exploit_name=exploit_name,
            target=target,
            success=False,
            output="",
            error=None,
            duration=0,
            actions_taken=[]
        )

        try:
            # Check safety first
            if not await self.safety_checker.check_safety(actions[0] if actions else ExploitAction(
                id='check', name='safety_check', description='', command='', severity='low', reversible=False
            ), target):
                result.error = "Safety check failed"
                return result

            if mode == ExploitationMode.DRY_RUN:
                result = await self._execute_dry_run(exploit_name, target, actions)

            elif mode == ExploitationMode.PRODUCTION:
                result = await self._execute_production(exploit_name, target, actions)

            elif mode == ExploitationMode.STEALTH:
                result = await self._execute_stealth(exploit_name, target, actions)

            result.duration = time.time() - start_time
            result.success = result.error is None

        except Exception as e:
            logger.error(f"Exploitation failed: {e}")
            result.error = str(e)
            result.success = False
            
            # Auto-rollback on failure if in production mode
            if mode == ExploitationMode.PRODUCTION:
                await self.rollback_manager.rollback_all()
                result.rolled_back = True

        return result

    async def _execute_dry_run(
        self,
        exploit_name: str,
        target: str,
        actions: List[ExploitAction]
    ) -> ExploitationResult:
        """Simulate exploit without actual execution"""
        logger.info(f"DRY-RUN MODE: Simulating {exploit_name}")
        
        output = f"DRY-RUN: Would execute {len(actions)} actions against {target}:\n"
        
        for action in actions:
            output += f"\n[{action.severity}] {action.name}\n"
            output += f"  Description: {action.description}\n"
            output += f"  Command: {action.command}\n"
            output += f"  Detection Risk: {action.detection_risk}\n"
            output += f"  Reversible: {action.reversible}\n"

        logger.success(f"DRY-RUN completed successfully")
        
        return ExploitationResult(
            timestamp=datetime.now().isoformat(),
            exploit_id=exploit_name,
            exploit_name=exploit_name,
            target=target,
            success=True,
            output=output,
            error=None,
            duration=0,
            actions_taken=actions
        )

    async def _execute_production(
        self,
        exploit_name: str,
        target: str,
        actions: List[ExploitAction]
    ) -> ExploitationResult:
        """Execute actual exploitation"""
        logger.warning(f"PRODUCTION MODE: Executing {exploit_name} against {target}")
        
        output = ""
        actions_taken = []

        for action in actions:
            try:
                logger.info(f"Executing: {action.name}")
                
                # Record in rollback manager
                self.rollback_manager.record_action(action)
                
                # Simulate execution (would actually run command in real scenario)
                exec_output = await self._execute_command(action.command, action.estimated_duration)
                
                output += f"\n✓ {action.name}: Success\n"
                actions_taken.append(action)

            except Exception as e:
                logger.error(f"Action failed: {action.name} - {e}")
                # Rollback on first failure
                await self.rollback_manager.rollback_all()
                return ExploitationResult(
                    timestamp=datetime.now().isoformat(),
                    exploit_id=exploit_name,
                    exploit_name=exploit_name,
                    target=target,
                    success=False,
                    output=output,
                    error=str(e),
                    duration=0,
                    actions_taken=actions_taken,
                    rolled_back=True
                )

        logger.success(f"Production exploitation completed")
        
        return ExploitationResult(
            timestamp=datetime.now().isoformat(),
            exploit_id=exploit_name,
            exploit_name=exploit_name,
            target=target,
            success=True,
            output=output,
            error=None,
            duration=0,
            actions_taken=actions_taken
        )

    async def _execute_stealth(
        self,
        exploit_name: str,
        target: str,
        actions: List[ExploitAction]
    ) -> ExploitationResult:
        """Execute with stealth mode (slower, anti-forensics)"""
        logger.info(f"STEALTH MODE: Executing {exploit_name} slowly...")
        
        output = "STEALTH MODE EXECUTION:\n"
        actions_taken = []

        for action in actions:
            try:
                logger.debug(f"Stealth executing: {action.name}")
                
                # Wait for rate limit
                await self.rate_limiter.wait()
                
                # Add random delay for anti-forensics
                import random
                random_delay = random.uniform(0.5, 2.0)
                await asyncio.sleep(random_delay)
                
                # Execute
                exec_output = await self._execute_command(action.command, action.estimated_duration)
                
                output += f"\n✓ {action.name}\n"
                actions_taken.append(action)

            except Exception as e:
                logger.error(f"Stealth action failed: {action.name} - {e}")
                return ExploitationResult(
                    timestamp=datetime.now().isoformat(),
                    exploit_id=exploit_name,
                    exploit_name=exploit_name,
                    target=target,
                    success=False,
                    output=output,
                    error=str(e),
                    duration=0,
                    actions_taken=actions_taken
                )

        logger.success(f"Stealth exploitation completed")
        
        return ExploitationResult(
            timestamp=datetime.now().isoformat(),
            exploit_id=exploit_name,
            exploit_name=exploit_name,
            target=target,
            success=True,
            output=output,
            error=None,
            duration=0,
            actions_taken=actions_taken
        )

    async def _execute_command(self, command: str, timeout: float) -> str:
        """Execute command (placeholder)"""
        await asyncio.sleep(timeout)
        return f"Executed: {command}"

    def set_mode(self, mode: ExploitationMode):
        """Set exploitation mode"""
        self.mode = mode
        logger.info(f"Exploitation mode set to: {mode.name}")

    def protect_asset(self, asset: str):
        """Mark asset as off-limits"""
        self.safety_checker.add_protected_asset(asset)

    def save_results(self, result: ExploitationResult, output_path: str):
        """Save exploitation results"""
        output_file = Path(output_path) / f"exploit_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        output_file.parent.mkdir(parents=True, exist_ok=True)

        data = {
            'timestamp': result.timestamp,
            'exploit_id': result.exploit_id,
            'exploit_name': result.exploit_name,
            'target': result.target,
            'success': result.success,
            'output': result.output,
            'error': result.error,
            'duration': result.duration,
            'rolled_back': result.rolled_back,
            'actions_taken': [
                {
                    'id': a.id,
                    'name': a.name,
                    'description': a.description,
                    'command': a.command,
                    'severity': a.severity,
                    'reversible': a.reversible
                }
                for a in result.actions_taken
            ]
        }

        with open(output_file, 'w') as f:
            json.dump(data, f, indent=2)

        logger.success(f"Exploitation results saved to {output_file}")
        return output_file
