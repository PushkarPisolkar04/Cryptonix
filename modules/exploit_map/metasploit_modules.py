"""Find Metasploit modules for CVEs"""
import asyncio
import subprocess
from typing import Dict, Any, List
from loguru import logger

class MetasploitModuleFinder:
    def __init__(self, config):
        self.config = config
        self.msfconsole = getattr(config.tools, 'msfconsole_path', 'msfconsole')
    
    async def find_modules(self, cve_id: str) -> List[Dict[str, Any]]:
        logger.info(f"Searching Metasploit modules for {cve_id}")
        
        try:
            # Search MSF database
            cmd = [self.msfconsole, '-q', '-x', f'search cve:{cve_id}; exit']
            proc = await asyncio.create_subprocess_exec(*cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE)
            stdout, _ = await asyncio.wait_for(proc.communicate(), timeout=30)
            output = stdout.decode('utf-8', errors='ignore')
            
            modules = []
            for line in output.split('\n'):
                if 'exploit/' in line or 'auxiliary/' in line:
                    parts = line.split()
                    if len(parts) >= 2:
                        modules.append({
                            'name': parts[0],
                            'path': parts[0],
                            'disclosure_date': parts[1] if len(parts) > 1 else '',
                            'rank': parts[2] if len(parts) > 2 else '',
                            'description': ' '.join(parts[3:]) if len(parts) > 3 else ''
                        })
            
            logger.success(f"Found {len(modules)} Metasploit modules")
            return modules
        except Exception as e:
            logger.error(f"MSF module search failed: {e}")
            return []
    
    async def get_module_info(self, module_path: str) -> Dict[str, Any]:
        try:
            cmd = [self.msfconsole, '-q', '-x', f'info {module_path}; exit']
            proc = await asyncio.create_subprocess_exec(*cmd, stdout=asyncio.subprocess.PIPE)
            stdout, _ = await proc.communicate()
            output = stdout.decode('utf-8', errors='ignore')
            
            return {'path': module_path, 'info': output}
        except Exception as e:
            logger.error(f"Failed to get module info: {e}")
            return {}
